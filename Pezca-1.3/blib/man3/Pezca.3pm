.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pezca 3"
.TH Pezca 3 "2016-01-26" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pezca \- a Perl extension for the easy channel access library (part of EPICS)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Pezca;
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Preface"
.IX Subsection "Preface"
This module gives access to some functions of the ezca library.
ezca is a library that simplifies the usage of channel-access, the
tcp/ip\-based protocol that is used in the Experimental Physics Industrial
Control System (\s-1EPICS\s0). This software is copyrighted by the terms described
in the file \s-1LICENSE\s0 which is part of the software distribution.
.SS "Implemented Functions:"
.IX Subsection "Implemented Functions:"
.IP "\(bu" 4
\&\fBGetDouble\fR
.Sp
.Vb 1
\&  ($errcode,$val)= Pezca::GetDouble($channel_name)
.Ve
.Sp
Gets a channel name as parameter (a string) and returns a list containing
of the error-code and the value of the operation.
This function can block when the channel is not immediately available.
This function replaces \fIPezca::Get()\fR.
.IP "\(bu" 4
\&\fBGetString\fR
.Sp
.Vb 1
\&  ($errcode,$val)= Pezca::GetString($channel_name)
.Ve
.Sp
gets a channel name as parameter (a string) and returns a list containing
of the value and the error-code of the operation.
The value is read as a string.
This function can block when the channel is not immediately available.
This function replaces \fIPezca::GetS()\fR.
.IP "\(bu" 4
\&\fBGetList\fR
.Sp
.Vb 1
\&  ($errcode,@values)= Pezca::GetList($channel_name,$type,$no)
.Ve
.Sp
gets a channel name, a type and the number of elements as parameter.
Known types (upper or lower case strings allowed) are byte, char, uchar,
short, ushort, long, ulong, int, uint, float, double and string.
The type name must not be omitted. If the type is unknown, the function
prints an error message and returns errcode \-1.
If the number of elements is omitted, all elements
of the channel are fetched. The function returns the error-code and
a list of elements.
This function can block when the channel is not immediately available.
.IP "\(bu" 4
\&\fBPutDouble\fR
.Sp
.Vb 1
\&  $errcode= Pezca::PutDouble($channel_name,$value)
.Ve
.Sp
get a channel name (string) and a value (floating point) as parameter. The
functions return the error-code of the put-operation. They can block when the
channel is not immediately available. Both functions are identical, the
\&\fIPezca::Put()\fR shouldn't be used in future applications since it is not
complient with the new naming convention of this module.
.IP "\(bu" 4
\&\fBPutDoubleOldCa\fR
.Sp
.Vb 1
\&  $errcode= Pezca::PutDoubleOldCa($channel_name,$value)
.Ve
.Sp
get a channel name (string) and a value (floating point) as parameter. The
functions return the error-code of the put-operation. They can block when the
channel is not immediately available. Both functions are identical, the
\&\fIPezca::Put()\fR shouldn't be used in future applications since it is not
complient with the new naming convention of this module.
.IP "\(bu" 4
\&\fBPutString\fR
.Sp
.Vb 1
\&  $errcode= Pezca::PutString($channel_name,$value)
.Ve
.Sp
get a channel name (string) and a value (string) as parameter. The
functions return the error-code of the opreration. They can block when the
channel is not immediately available.
\&\fIPezca::PutS()\fR shouldn't be used in future applications since it is not
complient with the new naming convention of this module.
.IP "\(bu" 4
\&\fBPutStringOldCa\fR
.Sp
.Vb 1
\&  $errcode= Pezca::PutStringOldCa($channel_name,$value)
.Ve
.Sp
get a channel name (string) and a value (string) as parameter. The
functions return the error-code of the opreration. They can block when the
channel is not immediately available.
\&\fIPezca::PutS()\fR shouldn't be used in future applications since it is not
complient with the new naming convention of this module.
.IP "\(bu" 4
\&\fBPutList\fR
.Sp
.Vb 1
\&  $errcode= Pezca::PutList($channel_name,$type,@values)
.Ve
.Sp
gets a channel name, a type and the list of elements as parameter.
Known types (upper or lower case strings allowed) are byte, char, uchar,
short, ushort, long, ulong, int, uint, float, double and string.
The type name must not be omitted. If the type is unknown, the function
prints an error message and returns errcode \-1.
The function returns the error-code of the operation.
This function can block when the channel is not immediately available.
.IP "\(bu" 4
\&\fBPutListOldCa\fR
.Sp
.Vb 1
\&  $errcode= Pezca::PutListOldCa($channel_name,$type,@values)
.Ve
.Sp
gets a channel name, a type and the list of elements as parameter.
Known types (upper or lower case strings allowed) are byte, char, uchar,
short, ushort, long, ulong, int, uint, float, double and string.
The type name must not be omitted. If the type is unknown, the function
prints an error message and returns errcode \-1.
The function returns the
error-code of the operation.
This function can block when the channel is not immediately available.
.IP "\(bu" 4
\&\fBGetControlLimits\fR
.Sp
.Vb 1
\&  ($errcode,$low,$high)= Pezca::GetControlLimits($channel)
.Ve
.Sp
Get the control limits of the given channel.
.IP "\(bu" 4
\&\fBGetGraphicLimits\fR
.Sp
.Vb 1
\&  ($errcode,$low,$high)= Pezca::GetGraphicLimits($channel)
.Ve
.Sp
Get the graphic limits of the given channel.
.IP "\(bu" 4
\&\fBGetNelem\fR
.Sp
.Vb 1
\&  ($errcode,$no)= Pezca::GetNelem($channel)
.Ve
.Sp
Get the number of elements of the given channel. See also
\&\fIPezca::GetList()\fR and \fIPezca::PutList()\fR.
.IP "\(bu" 4
\&\fBGetPrecision\fR
.Sp
.Vb 1
\&  ($errcode,$prec)= Pezca::GetPrecision($channel)
.Ve
.Sp
Get the precision of the given channel.
.IP "\(bu" 4
\&\fBGetUnits\fR
.Sp
.Vb 1
\&  ($errcode,$units)= Pezca::GetUnits($channel)
.Ve
.Sp
Get the engeneering units (a string) of the given channel.
.IP "\(bu" 4
\&\fBSetMonitorDouble\fR
.Sp
.Vb 1
\&  $errcode= Pezca::SetMonitorDouble($channel_name)
.Ve
.Sp
This function sets a channel-access monitor on the given channel. A buffer
is set up that is notified each time the value of the given channel changes.
All following calls of \fIPezca::GetDouble()\fR access that local buffer. This is
a way to reduce network traffic, when \fIPesca::GetDouble()\fR is called more
frequently than the underlying value actually changes. Note that the
data-types of the monitors and the get functions must match, so
\&\fIPezca::SetMonitorDouble()\fR should only be used with \fIPezca:GetDouble()\fR.
.IP "\(bu" 4
\&\fBSetMonitorString\fR
.Sp
.Vb 1
\&  $errcode= Pezca::SetMonitorString($channel_name)
.Ve
.Sp
This function sets a channel-access monitor on the given channel. A buffer
is set up that is notified each time the value of the given channel changes.
All following calls of \fIPezca::GetString()\fR access that local buffer. This is
a way to reduce network traffic, when \fIPesca::GetString()\fR is called more
frequently than the underlying value actually changes. Note that the
data-types of the monitors and the get functions must match, so
\&\fIPezca::SetMonitorString()\fR should only be used with \fIPezca:GetString()\fR.
.IP "\(bu" 4
\&\fBClearMonitorDouble\fR
.Sp
.Vb 1
\&  $errcode= Pezca::ClearMonitorDouble($channel_name)
.Ve
.Sp
These functions remove the monitor that was set up with
\&\fIPezca::SetMonitorDouble()\fR.
.IP "\(bu" 4
\&\fBClearMonitorString\fR
.Sp
.Vb 1
\&  $errcode= Pezca::ClearMonitorString($channel_name)
.Ve
.Sp
This function removes the monitor that was set up with 
\&\fIPezca::SetMonitorString()\fR.
.IP "\(bu" 4
\&\fBNewMonitorValueDouble\fR
.Sp
.Vb 1
\&  $errcode= Pezca::NewMonitorValueDouble($channel_name)
.Ve
.Sp
This function returns 1 if there is a new value in the monitor that was set 
up with \fIPezca::SetMonitorDouble()\fR.
.IP "\(bu" 4
\&\fBNewMonitorValueString\fR
.Sp
.Vb 1
\&  $errcode= Pezca::NewMonitorValueString($channel_name)
.Ve
.Sp
This function returns 1 if there is a new value in the monitor that was set 
up with \fIPezca::SetMonitorString()\fR.
.IP "\(bu" 4
\&\fBGetTimeout\fR
.Sp
.Vb 1
\&  $tmout= Pezca::GetTimeout()
.Ve
.Sp
Get the actual timeout of the ezca library (see ezca documentation)
.IP "\(bu" 4
\&\fBGetRetryCount\fR
.Sp
.Vb 1
\&  $retry_count= Pezca::GetRetryCount()
.Ve
.Sp
Get the actual Retry-Count of the ezca library (see ezca documentation)
.IP "\(bu" 4
\&\fBSetTimeout\fR
.Sp
.Vb 1
\&  $errcode= Pezca::SetTimeout($timeout)
.Ve
.Sp
Set the timeout of the ezca-library (see ezca documentation)
.IP "\(bu" 4
\&\fBSetTimeout\fR
.Sp
.Vb 1
\&  $errcode= Pezca::SetRetryCount($retry_count)
.Ve
.Sp
Set the retry-counter of the ezca-library (see ezca documentation)
.IP "\(bu" 4
\&\fBAutoErrorMessageOn\fR
.Sp
.Vb 1
\&  Pezca::AutoErrorMessageOn()
.Ve
.Sp
Switch ezca error-messages to stdout on (default)
.IP "\(bu" 4
\&\fBAutoErrorMessageOff\fR
.Sp
.Vb 1
\&  Pezca::AutoErrorMessageOff()
.Ve
.Sp
Switch ezca error-messages to stdout off
.IP "\(bu" 4
\&\fBPerror\fR
.Sp
.Vb 1
\&  Pezca::Perror($prefix)
.Ve
.Sp
Print the status and possible error string of the last
Channel Access call. The prefix string is prepended to the
string.
.IP "\(bu" 4
\&\fBGetErrorString\fR
.Sp
.Vb 1
\&  ($ret,$string)= Pezca::GetErrorString($prefix)
.Ve
.Sp
Return the status and possible error string of the last
Channel Access call. The prefix string is prepended to the
string that is returned. The return value \*(L"$ret\*(R" is the return code
of \fIezcaGetErrorString()\fR.
.IP "\(bu" 4
\&\fBDelay\fR
.Sp
.Vb 1
\&  $errcode= Pezca::Delay($time)
.Ve
.Sp
This function has to be called when a monitor is set up and there is a rather
long time between two consecutive calls of \fIPesca::Get()\fR. The given parameter
should be 0.01 (see also ezca documentation).
.IP "\(bu" 4
\&\fBPend_Event\fR
.Sp
.Vb 1
\&  $errcode= Pezca::Pend_Event($time)
.Ve
.Sp
This function calls \fIca_pend_event()\fR which gives channel access the chance to
process incoming data. The parameter is a timeout-time (in seconds), after
which Pend_Event returns.
.SS "functions for backwards-compability:"
.IX Subsection "functions for backwards-compability:"
These functions are here for backwards compability only. Do not
use them in future applications.
.IP "\(bu" 4
\&\fBGet\fR
.Sp
.Vb 1
\&  ($val,$errcode)= Pezca::Get($channel_name)
.Ve
.Sp
Similar to \fIPezca::GetDouble()\fR
.IP "\(bu" 4
\&\fBGetS\fR
.Sp
.Vb 1
\&  ($val,$errcode)= Pezca::GetS($channel_name)
.Ve
.Sp
Similar to \fIPezca::GetString()\fR
.IP "\(bu" 4
\&\fBPut\fR
.Sp
.Vb 1
\&  $errcode= Pezca::Put($channel_name,$value)
.Ve
.Sp
Similar to \fIPezca::PutDouble()\fR
.IP "\(bu" 4
\&\fBPutS\fR
.Sp
.Vb 1
\&  $errcode= Pezca::PutS($channel_name,$value)
.Ve
.Sp
Similar to \fIPezca::PutString()\fR
.IP "\(bu" 4
\&\fBSetMonitor\fR
.Sp
.Vb 1
\&  $errcode= Pezca::SetMonitor($channel_name)
.Ve
.Sp
Similar to \fIPezca::SetMonitorDouble()\fR
.IP "\(bu" 4
\&\fBSetMonitorS\fR
.Sp
.Vb 1
\&  $errcode= Pezca::SetMonitorS($channel_name)
.Ve
.Sp
Similar to \fIPezca::SetMonitorString()\fR
.IP "\(bu" 4
\&\fBClearMonitor\fR
.Sp
.Vb 1
\&  $errcode= Pezca::ClearMonitor($channel_name)
.Ve
.Sp
Similar to \fIPezca::ClearMonitorDouble()\fR
.IP "\(bu" 4
\&\fBClearMonitorS\fR
.Sp
.Vb 1
\&  $errcode= Pezca::ClearMonitorS($channel_name)
.Ve
.Sp
Similar to \fIPezca::ClearMonitorString()\fR
.IP "\(bu" 4
\&\fBNewMonitorValue\fR
.Sp
.Vb 1
\&  $errcode= Pezca::NewMonitorValue($channel_name)
.Ve
.Sp
Similar to \fIPezca::NewMonitorValueDouble()\fR
.IP "\(bu" 4
\&\fBNewMonitorValueS\fR
.Sp
.Vb 1
\&  $errcode= Pezca::NewMonitorValueS($channel_name)
.Ve
.Sp
Similar to \fIPezca::NewMonitorValueString()\fR
.SH "AUTHOR"
.IX Header "AUTHOR"
Goetz Pfeiffer,  Goetz.Pfeiffer@helmholtz\-berlin.de
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1),
.PP
EPICS-documentation (especially ezca, the easy channel access library)
