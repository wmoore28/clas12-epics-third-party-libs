/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of Pezca.xs. Do not edit this file, edit Pezca.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Pezca.xs"
/*
 This software is copyrighted by the
 Helmholtz-Zentrum Berlin fuer Materialien und Energie GmbH (HZB),
 Berlin, Germany.
 The following terms apply to all files associated with the software.

 HZB hereby grants permission to use, copy and modify this
 software and its documentation for non-commercial, educational or
 research purposes provided that existing copyright notices are
 retained in all copies.

 The receiver of the software provides HZB with all enhancements,
 including complete translations, made by the receiver.

 IN NO EVENT SHALL HZB BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
 SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE
 OF THIS SOFTWARE, ITS DOCUMENTATION OR ANY DERIVATIVES THEREOF, EVEN
 IF HZB HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 HZB SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED
 TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 PURPOSE, AND NON-INFRINGEMENT. THIS SOFTWARE IS PROVIDED ON AN "AS IS"
 BASIS, AND HZB HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT,
 UPDATES, ENHANCEMENTS OR MODIFICATIONS.
*/

/* PERL_UNUSED_VAR(ix) was added to remove compiler warnings. See also:
 * https://mail.gnome.org/archives/gtk-perl-list/2003-October/msg00107.htm*/

#ifdef __cplusplus
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifdef __cplusplus
}
#endif

#include <ctype.h>  /* toupper */

#include <stdio.h>  /* printf, only for debugging */

#include <tsDefs.h>
#include <cadef.h>
#include <ezca.h>

#ifndef EZCA_ABORTED
#define EZCA_VER 20070625
#else
#define EZCA_VER 20111019
#endif

/* typedef char stringy[80]; */

#define STRINGBUFSIZE 80
/* Buffer size increased by Sergey 2003/07/22 -- according to Mark Rivers */
/* #define LISTBUFSIZE 8192 */
#define LISTBUFSIZE 16000

static int strcmp_ignore_case(char *s1, char *s2)
  { register char c1, c2;

    for(; (*s1!=0) || (*s2!=0); s1++, s2++)
      { c1= toupper(*s1); c2= toupper(*s2);
        if (c1<c2)
          return(-1);
        if (c1>c2)
          return(1);
      };
    return(0);
  };

static int get_type(char *type, int *etype, int *eshift)
  { /* recognized: byte, char, uchar
                   short, ushort,
                   long, ulong, int, uint,
                   float,
                   double,
                   string */
    if (0==strcmp_ignore_case(type, "BYTE"))
      { *etype= ezcaByte;   *eshift=0; return(1); }
    if (0==strcmp_ignore_case(type, "CHAR"))
      { *etype= ezcaByte;   *eshift=0; return(1); }
    if (0==strcmp_ignore_case(type, "UCHAR"))
      { *etype= ezcaByte;   *eshift=0; return(1); }

    if (0==strcmp_ignore_case(type, "SHORT"))
      { *etype= ezcaShort;  *eshift=1; return(1); }
    if (0==strcmp_ignore_case(type, "USHORT"))
      { *etype= ezcaShort;  *eshift=1; return(1); }

    if (0==strcmp_ignore_case(type, "LONG"))
      { *etype= ezcaLong;   *eshift=2; return(1); }
    if (0==strcmp_ignore_case(type, "ULONG"))
      { *etype= ezcaLong;   *eshift=2; return(1); }
    if (0==strcmp_ignore_case(type, "INT"))
      { *etype= ezcaLong;   *eshift=2; return(1); }
    if (0==strcmp_ignore_case(type, "UINT"))
      { *etype= ezcaLong;   *eshift=2; return(1); }

    if (0==strcmp_ignore_case(type, "FLOAT"))
      { *etype= ezcaFloat;  *eshift=2; return(1); }

    if (0==strcmp_ignore_case(type, "DOUBLE"))
      { *etype= ezcaDouble; *eshift=3; return(1); }

    if (0==strcmp_ignore_case(type, "STRING"))
      { *etype= ezcaString; *eshift=0; return(1); }

    return(0); /* error: unknown type */
  }


#line 125 "Pezca.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 267 "Pezca.c"

XS_EUPXS(XS_Pezca_GetDouble); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_GetDouble)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "channel");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char*	channel = (char *)SvPV_nolen(ST(0))
;
#line 128 "Pezca.xs"
        double r;
        int    ret;
        ret= ezcaGet(channel,ezcaDouble, 1, &r);
        if (ret!=0)
          { EXTEND(sp, 1);
            PUSHs(sv_2mortal(newSViv(ret)));
          }
        else
          { EXTEND(sp, 2);
            if (ix==0) /* function was called by it's original name */
              { PUSHs(sv_2mortal(newSViv(ret)));
                PUSHs(sv_2mortal(newSVnv(r)));
              }
            else       /* function was called as "Pezca::Get(..)" */
              { PUSHs(sv_2mortal(newSVnv(r)));
                PUSHs(sv_2mortal(newSViv(ret)));
              }
          }
#line 300 "Pezca.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Pezca_GetList); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_GetList)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "channel, type=\"\", no=0");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char*	channel = (char *)SvPV_nolen(ST(0))
;
	char*	type;
	int	no;
#line 154 "Pezca.xs"
        char   buf[LISTBUFSIZE];
        int    etype;
        int    eshift;
        int    ret=0;
        int    i;
#line 326 "Pezca.c"

	if (items < 2)
	    type = "";
	else {
	    type = (char *)SvPV_nolen(ST(1))
;
	}

	if (items < 3)
	    no = 0;
	else {
	    no = (int)SvIV(ST(2))
;
	}
#line 160 "Pezca.xs"
        /* recognized type:
          "byte","char","short","long","int","float","double","string"
           only the first two characters are evaluated (runtime effeciency)*/

        if (!get_type(type, &etype, &eshift))
          { /* unknown type */
            fprintf(stderr, "Pezca: unknown type string: \"%s\"\n",type);
            ret= -1;
            EXTEND(sp, 1); /* room for 1 element on the stack */
            PUSHs(sv_2mortal(newSViv(ret)));
            return;
          }

        if (no==0)
          { ret= ezcaGetNelem(channel, &no);
            if (ret!=0)
              { EXTEND(sp, 1); /* room for 1 element on the stack */
                PUSHs(sv_2mortal(newSViv(ret)));
                return;
              }
          }

        if ((no << eshift)>LISTBUFSIZE)
          no= LISTBUFSIZE >> eshift;

        ret= ezcaGet(channel,etype, no, buf);
        if (ret!=0)
          { EXTEND(sp, 1); /* room for 1 element on the stack */
            PUSHs(sv_2mortal(newSViv(ret)));
            return;
          }

        EXTEND(sp, no+1); /* room for no+1 elements on the stack */
        PUSHs(sv_2mortal(newSViv(ret)));
        switch(etype)
          { case ezcaByte:
                       { char *p= buf;

                         for(i=no;i>0;i--,p++)
                           PUSHs(sv_2mortal(newSViv((int)(*p))));
                         break;
                       }
            case ezcaShort:
                       { epicsInt16 *p= (epicsInt16*)buf;

                         for(i=no;i>0;i--,p++)
                           PUSHs(sv_2mortal(newSViv((int)(*p))));
                         break;
                       }
            case ezcaLong:
                       { epicsInt32 *p= (epicsInt32*)buf;

                         for(i=no;i>0;i--,p++)
                           PUSHs(sv_2mortal(newSViv(*p)));
                         break;
                       }
            case ezcaFloat:
                       { float *p= (float*)buf;

                         for(i=no;i>0;i--,p++)
                           PUSHs(sv_2mortal(newSVnv((double)(*p))));
                         break;
                       }
            case ezcaDouble:
                       { double *p= (double*)buf;

                         for(i=no;i>0;i--,p++)
                           PUSHs(sv_2mortal(newSVnv(*p)));
                         break;
                       }
            case ezcaString:
                       { char *p= buf;
                         char *e;

                         for(i=no;i>0;i--,p++)
                           { for(e=p;*e!=0;e++); /* DANGEROUS */
                             PUSHs(sv_2mortal(newSVpv(p,0)));
                             p= e+1;
                           };
                         break;
                       }
          }
#line 424 "Pezca.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Pezca_GetString); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_GetString)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "channel");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char*	channel = (char *)SvPV_nolen(ST(0))
;
#line 253 "Pezca.xs"
        /* errcode comes first ! */
        char   st[STRINGBUFSIZE];
        int    ret;
        ret= ezcaGet(channel,ezcaString, 1, st);
        if (ret!=0)
          { EXTEND(sp, 1);
            PUSHs(sv_2mortal(newSViv(ret)));
          }
        else
          { EXTEND(sp, 2);
            if (ix==0) /* function was called by it's original name */
              { PUSHs(sv_2mortal(newSViv(ret)));
                PUSHs(sv_2mortal(newSVpv(st,0)));
              }
            else       /* function was called as "Pezca::GetS(..)" */
              { PUSHs(sv_2mortal(newSVpv(st,0)));
                PUSHs(sv_2mortal(newSViv(ret)));
              }
          }
#line 463 "Pezca.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Pezca_PutDouble); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_PutDouble)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "channel, val");
    {
	char*	channel = (char *)SvPV_nolen(ST(0))
;
	double	val = (double)SvNV(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 283 "Pezca.xs"
        PERL_UNUSED_VAR(ix);
        RETVAL=ezcaPut(channel,ezcaDouble, 1, &val);
#line 487 "Pezca.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pezca_PutDoubleOldCa); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_PutDoubleOldCa)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "channel, val");
    {
	char*	channel = (char *)SvPV_nolen(ST(0))
;
	double	val = (double)SvNV(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 296 "Pezca.xs"
        PERL_UNUSED_VAR(ix);
        RETVAL=ezcaPutOldCa(channel,ezcaDouble, 1, &val);
#line 511 "Pezca.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pezca_PutList); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_PutList)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "channel, type, ...");
    {
	char*	channel = (char *)SvPV_nolen(ST(0))
;
	char*	type = (char *)SvPV_nolen(ST(1))
;
#line 307 "Pezca.xs"
        char   buf[LISTBUFSIZE];
        int    etype;
        int    eshift;
        int    no=0;
        int    i;
#line 535 "Pezca.c"
	int	RETVAL;
	dXSTARG;
#line 313 "Pezca.xs"
        /* recognized type:
          "byte","char","short","long","int","float","double"
           only the first two characters are evaluated (runtime effeciency)*/

        if (!get_type(type, &etype, &eshift))
          { fprintf(stderr, "Pezca: unknown type string: \"%s\"\n",type);
            RETVAL= -1;
          }
        else
          {

            no= items-2;
            if ((no << eshift)>LISTBUFSIZE)
              no= LISTBUFSIZE >> eshift;

            switch(etype)
              { case ezcaByte:
                           { char *p= buf;

                             for(i=2;i<items;i++)
                               { *(p++)= (char)SvIV(ST(i)); }
                             break;
                           }
                case ezcaShort:
                           { epicsInt16 *p= (epicsInt16*)buf;

                             for(i=2;i<items;i++)
                               { *(p++)= (epicsInt16)SvIV(ST(i)); }
                             break;
                           }
                case ezcaLong:
                           { epicsInt32 *p= (epicsInt32*)buf;

                             for(i=2;i<items;i++)
                               { *(p++)= (epicsInt32)SvIV(ST(i)); }
                             break;
                           }
                case ezcaFloat:
                           { float *p= (float*)buf;

                             for(i=2;i<items;i++)
                               { *(p++)= (float)SvNV(ST(i)); }
                             break;
                           }
                case ezcaDouble:
                           { double *p= (double*)buf;

                             for(i=2;i<items;i++)
                               { *(p++)= (double)SvNV(ST(i)); }
                             break;
                           }
                /* the following is DANGEROUS, not tested and currently
                   not used */
                case ezcaString:
                           { char *p= buf;

                             for(i=2;i<items;i++)
                               { unsigned len;
                                 char *src= (char*)(SvPV(ST(i),len));
                                 strcpy(p, src);/*DANGEROUS*/
                                 p+= (len+1);
                               }
                             break;
                           }
              };

          }
        RETVAL=ezcaPut(channel,etype, no, buf);
#line 607 "Pezca.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pezca_PutListOldCa); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_PutListOldCa)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "channel, type, ...");
    {
	char*	channel = (char *)SvPV_nolen(ST(0))
;
	char*	type = (char *)SvPV_nolen(ST(1))
;
#line 390 "Pezca.xs"
        char   buf[LISTBUFSIZE];
        int    etype;
        int    eshift;
        int    no=0;
        int    i;
#line 631 "Pezca.c"
	int	RETVAL;
	dXSTARG;
#line 396 "Pezca.xs"
        /* recognized type:
          "byte","char","short","long","int","float","double"
           only the first two characters are evaluated (runtime effeciency)*/

        if (!get_type(type, &etype, &eshift))
          { fprintf(stderr, "Pezca: unknown type string: \"%s\"\n",type);
            RETVAL= -1;
          }
        else
          {

            no= items-2;
            if ((no << eshift)>LISTBUFSIZE)
              no= LISTBUFSIZE >> eshift;

            switch(etype)
              { case ezcaByte:
                           { char *p= buf;

                             for(i=2;i<items;i++)
                               { *(p++)= (char)SvIV(ST(i)); }
                             break;
                           }
                case ezcaShort:
                           { epicsInt16 *p= (epicsInt16*)buf;

                             for(i=2;i<items;i++)
                               { *(p++)= (epicsInt16)SvIV(ST(i)); }
                             break;
                           }
                case ezcaLong:
                           { epicsInt32 *p= (epicsInt32*)buf;

                             for(i=2;i<items;i++)
                               { *(p++)= (epicsInt32)SvIV(ST(i)); }
                             break;
                           }
                case ezcaFloat:
                           { float *p= (float*)buf;

                             for(i=2;i<items;i++)
                               { *(p++)= (float)SvNV(ST(i)); }
                             break;
                           }
                case ezcaDouble:
                           { double *p= (double*)buf;

                             for(i=2;i<items;i++)
                               { *(p++)= (double)SvNV(ST(i)); }
                             break;
                           }
                /* the following is DANGEROUS, not tested and currently
                   not used */
                case ezcaString:
                           { char *p= buf;

                             for(i=2;i<items;i++)
                               { unsigned len;
                                 char *src= (char*)(SvPV(ST(i),len));
                                 strcpy(p, src);/*DANGEROUS*/
                                 p+= (len+1);
                               }
                             break;
                           }
              };

          }
        RETVAL=ezcaPutOldCa(channel,etype, no, buf);
#line 703 "Pezca.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pezca_PutString); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_PutString)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "channel, val");
    {
	char*	channel = (char *)SvPV_nolen(ST(0))
;
	char*	val = (char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 478 "Pezca.xs"
        PERL_UNUSED_VAR(ix);
        RETVAL=ezcaPut(channel,ezcaString, 1, val);
#line 727 "Pezca.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pezca_PutStringOldCa); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_PutStringOldCa)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "channel, val");
    {
	char*	channel = (char *)SvPV_nolen(ST(0))
;
	char*	val = (char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 491 "Pezca.xs"
        PERL_UNUSED_VAR(ix);
        RETVAL=ezcaPutOldCa(channel,ezcaString, 1, val);
#line 751 "Pezca.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pezca_GetControlLimits); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_GetControlLimits)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "channel");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	channel = (char *)SvPV_nolen(ST(0))
;
#line 501 "Pezca.xs"
        /* errcode comes first ! */
        int  ret;
        double low,high;
        ret= ezcaGetControlLimits(channel, &low, &high);
        if (ret!=0)
          { EXTEND(sp, 1);
            PUSHs(sv_2mortal(newSViv(ret)));
          }
        else
          { EXTEND(sp, 3);
            PUSHs(sv_2mortal(newSViv(ret)));
            PUSHs(sv_2mortal(newSVnv(low)));
            PUSHs(sv_2mortal(newSVnv(high)));
          }
#line 784 "Pezca.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Pezca_GetGraphicLimits); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_GetGraphicLimits)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "channel");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	channel = (char *)SvPV_nolen(ST(0))
;
#line 521 "Pezca.xs"
        /* errcode comes first ! */
        int  ret;
        double low,high;
        ret= ezcaGetGraphicLimits(channel, &low, &high);
        if (ret!=0)
          { EXTEND(sp, 1);
            PUSHs(sv_2mortal(newSViv(ret)));
          }
        else
          { EXTEND(sp, 3);
            PUSHs(sv_2mortal(newSViv(ret)));
            PUSHs(sv_2mortal(newSVnv(low)));
            PUSHs(sv_2mortal(newSVnv(high)));
          }
#line 817 "Pezca.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Pezca_GetNelem); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_GetNelem)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "channel");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	channel = (char *)SvPV_nolen(ST(0))
;
#line 541 "Pezca.xs"
        /* errcode comes first ! */
        int  ret;
        int  val;
        ret= ezcaGetNelem(channel, &val);
        if (ret!=0)
          { EXTEND(sp, 1);
            PUSHs(sv_2mortal(newSViv(ret)));
          }
        else
          { EXTEND(sp, 2);
            PUSHs(sv_2mortal(newSViv(ret)));
            PUSHs(sv_2mortal(newSViv(val)));
          }
#line 849 "Pezca.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Pezca_GetPrecision); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_GetPrecision)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "channel");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	channel = (char *)SvPV_nolen(ST(0))
;
#line 560 "Pezca.xs"
        /* errcode comes first ! */
        int   ret;
        short val;
        ret= ezcaGetPrecision(channel, &val);
        if (ret!=0)
          { EXTEND(sp, 1);
            PUSHs(sv_2mortal(newSViv(ret)));
          }
        else
          { EXTEND(sp, 2);
            PUSHs(sv_2mortal(newSViv(ret)));
            PUSHs(sv_2mortal(newSViv(val)));
          }
#line 881 "Pezca.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Pezca_GetUnits); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_GetUnits)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "channel");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	channel = (char *)SvPV_nolen(ST(0))
;
#line 579 "Pezca.xs"
        /* errcode comes first ! */
        int   ret;
        char   st[STRINGBUFSIZE];
        ret= ezcaGetUnits(channel, st);
        if (ret!=0)
          { EXTEND(sp, 1);
            PUSHs(sv_2mortal(newSViv(ret)));
          }
        else
          { EXTEND(sp, 2);
            PUSHs(sv_2mortal(newSViv(ret)));
            PUSHs(sv_2mortal(newSVpv(st,0)));
          }
#line 913 "Pezca.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Pezca_GetTimeout); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_GetTimeout)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	double	RETVAL;
	dXSTARG;
#line 597 "Pezca.xs"
        RETVAL=ezcaGetTimeout();
#line 931 "Pezca.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pezca_GetRetryCount); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_GetRetryCount)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 605 "Pezca.xs"
        RETVAL=ezcaGetRetryCount();
#line 949 "Pezca.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pezca_SetTimeout); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_SetTimeout)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sec");
    {
	double	sec = (double)SvNV(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 614 "Pezca.xs"
        RETVAL=ezcaSetTimeout((float)sec);
#line 969 "Pezca.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pezca_SetRetryCount); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_SetRetryCount)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "retry");
    {
	int	retry = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 623 "Pezca.xs"
        RETVAL=ezcaSetRetryCount(retry);
#line 989 "Pezca.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pezca_AutoErrorMessageOn); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_AutoErrorMessageOn)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 631 "Pezca.xs"
        ezcaAutoErrorMessageOn();
#line 1005 "Pezca.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pezca_AutoErrorMessageOff); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_AutoErrorMessageOff)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 637 "Pezca.xs"
        ezcaAutoErrorMessageOff();
#line 1020 "Pezca.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pezca_Perror); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_Perror)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "prefix");
    {
	char *	prefix = (char *)SvPV_nolen(ST(0))
;
#line 644 "Pezca.xs"
        ezcaPerror(prefix);
#line 1037 "Pezca.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Pezca_GetErrorString); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_GetErrorString)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "prefix");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	prefix = (char *)SvPV_nolen(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 651 "Pezca.xs"
        PERL_UNUSED_VAR(targ);
        PERL_UNUSED_VAR(RETVAL);
	char *buf;
	int ret;
	ret= ezcaGetErrorString(prefix,&buf);
	EXTEND(sp, 2);
        PUSHs(sv_2mortal(newSViv(ret)));
	PUSHs(sv_2mortal(newSVpv(buf,0)));
	ezcaFree(buf);
#line 1066 "Pezca.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Pezca_SetMonitorDouble); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_SetMonitorDouble)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "pvname");
    {
	char *	pvname = (char *)SvPV_nolen(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 680 "Pezca.xs"
        PERL_UNUSED_VAR(ix);
#if EZCA_VER < 20111019
        RETVAL=ezcaSetMonitor(pvname, ezcaDouble);
#else
        RETVAL=ezcaSetMonitor(pvname, ezcaDouble, 1);
#endif
#line 1092 "Pezca.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pezca_SetMonitorString); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_SetMonitorString)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "pvname");
    {
	char *	pvname = (char *)SvPV_nolen(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 696 "Pezca.xs"
        PERL_UNUSED_VAR(ix);
#if EZCA_VER < 20111019
        RETVAL=ezcaSetMonitor(pvname, ezcaString);
#else
        RETVAL=ezcaSetMonitor(pvname, ezcaString, 1);
#endif
#line 1118 "Pezca.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pezca_ClearMonitorDouble); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_ClearMonitorDouble)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "pvname");
    {
	char *	pvname = (char *)SvPV_nolen(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 713 "Pezca.xs"
        PERL_UNUSED_VAR(ix);
        RETVAL=ezcaClearMonitor(pvname, ezcaDouble);
#line 1140 "Pezca.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pezca_ClearMonitorString); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_ClearMonitorString)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "pvname");
    {
	char *	pvname = (char *)SvPV_nolen(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 725 "Pezca.xs"
        PERL_UNUSED_VAR(ix);
        RETVAL=ezcaClearMonitor(pvname, ezcaString);
#line 1162 "Pezca.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pezca_NewMonitorValueDouble); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_NewMonitorValueDouble)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "pvname");
    {
	char *	pvname = (char *)SvPV_nolen(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 738 "Pezca.xs"
        PERL_UNUSED_VAR(ix);
        RETVAL=ezcaNewMonitorValue(pvname, ezcaDouble);
#line 1184 "Pezca.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pezca_NewMonitorValueString); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_NewMonitorValueString)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "pvname");
    {
	char *	pvname = (char *)SvPV_nolen(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 750 "Pezca.xs"
        PERL_UNUSED_VAR(ix);
        RETVAL=ezcaNewMonitorValue(pvname, ezcaString);
#line 1206 "Pezca.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pezca_Delay); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_Delay)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sec");
    {
	double	sec = (double)SvNV(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 761 "Pezca.xs"
        RETVAL=ezcaDelay((float)sec);
#line 1226 "Pezca.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Pezca_Pend_Event); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Pezca_Pend_Event)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "timeout");
    {
	double	timeout = (double)SvNV(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 770 "Pezca.xs"
        RETVAL= ca_pend_event(timeout);
#line 1246 "Pezca.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Pezca); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Pezca)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

    {
        CV * cv;

        cv = newXSproto_portable("Pezca::Get", XS_Pezca_GetDouble, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("Pezca::GetDouble", XS_Pezca_GetDouble, file, "$");
        XSANY.any_i32 = 0;
        (void)newXSproto_portable("Pezca::GetList", XS_Pezca_GetList, file, "$;$$");
        cv = newXSproto_portable("Pezca::GetString", XS_Pezca_GetString, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("Pezca::GetS", XS_Pezca_GetString, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("Pezca::Put", XS_Pezca_PutDouble, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("Pezca::PutDouble", XS_Pezca_PutDouble, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("Pezca::PutDoubleOldCa", XS_Pezca_PutDoubleOldCa, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("Pezca::PutOldCa", XS_Pezca_PutDoubleOldCa, file, "$$");
        XSANY.any_i32 = 1;
        (void)newXSproto_portable("Pezca::PutList", XS_Pezca_PutList, file, "$$@");
        (void)newXSproto_portable("Pezca::PutListOldCa", XS_Pezca_PutListOldCa, file, "$$@");
        cv = newXSproto_portable("Pezca::PutS", XS_Pezca_PutString, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("Pezca::PutString", XS_Pezca_PutString, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("Pezca::PutStringOldCa", XS_Pezca_PutStringOldCa, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("Pezca::PutSOldCa", XS_Pezca_PutStringOldCa, file, "$$");
        XSANY.any_i32 = 1;
        (void)newXSproto_portable("Pezca::GetControlLimits", XS_Pezca_GetControlLimits, file, "$");
        (void)newXSproto_portable("Pezca::GetGraphicLimits", XS_Pezca_GetGraphicLimits, file, "$");
        (void)newXSproto_portable("Pezca::GetNelem", XS_Pezca_GetNelem, file, "$");
        (void)newXSproto_portable("Pezca::GetPrecision", XS_Pezca_GetPrecision, file, "$");
        (void)newXSproto_portable("Pezca::GetUnits", XS_Pezca_GetUnits, file, "$");
        (void)newXSproto_portable("Pezca::GetTimeout", XS_Pezca_GetTimeout, file, "");
        (void)newXSproto_portable("Pezca::GetRetryCount", XS_Pezca_GetRetryCount, file, "");
        (void)newXSproto_portable("Pezca::SetTimeout", XS_Pezca_SetTimeout, file, "$");
        (void)newXSproto_portable("Pezca::SetRetryCount", XS_Pezca_SetRetryCount, file, "$");
        (void)newXSproto_portable("Pezca::AutoErrorMessageOn", XS_Pezca_AutoErrorMessageOn, file, "");
        (void)newXSproto_portable("Pezca::AutoErrorMessageOff", XS_Pezca_AutoErrorMessageOff, file, "");
        (void)newXSproto_portable("Pezca::Perror", XS_Pezca_Perror, file, "$");
        (void)newXSproto_portable("Pezca::GetErrorString", XS_Pezca_GetErrorString, file, "$");
        cv = newXSproto_portable("Pezca::SetMonitorDouble", XS_Pezca_SetMonitorDouble, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("Pezca::SetMonitor", XS_Pezca_SetMonitorDouble, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("Pezca::SetMonitorString", XS_Pezca_SetMonitorString, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("Pezca::SetMonitorS", XS_Pezca_SetMonitorString, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("Pezca::ClearMonitor", XS_Pezca_ClearMonitorDouble, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("Pezca::ClearMonitorDouble", XS_Pezca_ClearMonitorDouble, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("Pezca::ClearMonitorS", XS_Pezca_ClearMonitorString, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("Pezca::ClearMonitorString", XS_Pezca_ClearMonitorString, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("Pezca::NewMonitorValueDouble", XS_Pezca_NewMonitorValueDouble, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("Pezca::NewMonitorValue", XS_Pezca_NewMonitorValueDouble, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("Pezca::NewMonitorValueS", XS_Pezca_NewMonitorValueString, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("Pezca::NewMonitorValueString", XS_Pezca_NewMonitorValueString, file, "$");
        XSANY.any_i32 = 0;
        (void)newXSproto_portable("Pezca::Delay", XS_Pezca_Delay, file, "$");
        (void)newXSproto_portable("Pezca::Pend_Event", XS_Pezca_Pend_Event, file, "$");
    }
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

